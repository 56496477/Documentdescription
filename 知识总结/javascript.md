## js 数据类型

* 基本类型(栈 stack) : Number、String 、Boolean、Null和Undefined , Symbol(es6新增)
* 基本数据类型是按值访问 高低分配,栈内存最大是8MB, String:是特殊的栈内存 ,程序员分配

 * 引用类型(堆 heap) :Object 、Array 、Function 、Data
 * 引用类型数据在栈内存中保存的实际上是对象在堆内存中的引用地址(指针),向高分配,系统自动分配

##### 堆栈空间分配区别：
>*  栈（操作系统）：由操作系统自动分配释放 ，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈；
>*  堆（操作系统）： 一般由程序员分配释放，若程序员不释放，程序结束时可能由OS回收，分配方式倒是类似于链表。

#####  二、堆栈缓存方式区别：
>*  栈使用的是一级缓存， 他们通常都是被调用时处于存储空间中，调用完毕立即释放；
>*  堆是存放在二级缓存中，生命周期由虚拟机的垃圾回收算法来决定（并不是一旦成为孤儿对象就能被回收）。所以调用这些对象的速度要相对来得低一些。

###### 堆 、栈数据结构区别：
>*  堆（数据结构）：堆可以被看成是一棵树，如：堆排序；
>*  栈（数据结构）：一种先进后出的数据结构。
> Symbol，表示独一无二的值, Symbol最大的用途是用来定义对象的唯一属性名;
*	Symbol值通过Symbol函数生成  let symbol1 = Symbol();
*	typeof运算符用于Symbol类型值，返回symbol;
*	Symbol不是一个构造函数，如果用new Symbol会报错;
*	由于Symbol值不是对象，所以不能添加属性;
*	Symbol值不能与其他类型的值进行运算;
*	Symbol值可以显式转为字符串，也可以转为布尔值，但是不能转为数值;
*	在对象的内部，使用Symbol值定义属性时，Symbol值必须放在方括号之中，如果不放在方括号中，该属性名就是字符串，而不是代表的Symbol值。
*	Symbol值作为对象属性名时，不能用点运算符。由于点运算符后面总是字符串，所以不会读取name作为标识名所指代的那个值，导致属性名实际上是一个字符串，而不是一个Symbol值。

## 数据结构
> 数据结构的基本操作的设置的最重要的准则是,实现应用程序与存储结构的独立
> 数据结构:数据的存储+算法
![node](img/tree.png)
```javascript
数据结构:
    逻辑结构:反映数据之间的逻辑关系;
    存储结构:数据结构在计算机中的表示;
逻辑结构:
        集合:结构中的数据元素除了同属于一种类型外，别无其它关系。(无逻辑关系)
        线性结构 :数据元素之间一对一的关系(线性表)
        树形结构 :数据元素之间一对多的关系(非线性)
        图状结构或网状结构: 结构中的数据元素之间存在多对多的关系(非线性) 
存储结构:
        顺序存储数据结构
        链式存储数据结构
        索引存储数据结构
        散列存储数据结构
线性结构 : 
* 队列: 也是一种运算受限的线性表。它只允许在表的一端进行插入，而在另一端进行删除。允许删除的一端称为队头(front)，允许插入的一端称为队尾(rear)。先进先出。
* 栈: 是限制在表的一端进行插入和删除运算的线性表，通常称插入、删除的这一端为栈顶(Top)，另一端为栈底(Bottom)。先进后出。top= -1时为空栈，top=0只能说明栈中只有一个元素，并且元素进栈时top应该自增. 后进先出
* 串 :是零个或多个字符组成的有限序列。长度为零的串称为空串(Empty String)，它不包含任何字符。通常将仅由一个或多个空格组成的串称为空白串(Blank String) 注意：空串和空白串的不同，例如“ ”和“”分别表示长度为1的空白串和长度为0的空串。
* 树:一种非线性结构。树是递归结构，在树的定义中又用到了树的概念
    有序数:子节点之间有顺序关系
    无序树:子节点之间没有顺序关系
    二叉树:一种非线性结构。树是递归结构，在树的定义中又用到了树的概念

* 遍历二叉树：使得每一个结点均被访问一次，而且仅被访问一次。非递归的遍历实现要利用栈。
    先序遍历DLR：根节点->左子树->右子树(广度遍历)
    中序遍历LDR：左子树->根节点->右子树。必须要有中序遍历才能得到一棵二叉树的正确顺序(广度遍历)
    后续遍历LRD：左子树->右子树->根节点。需要栈的支持。(广度遍历)
    层次遍历：用一维数组存储二叉树时,总是以层次遍历的顺序存储结点。层次遍历应该借助队列。(深度遍历)

```
![node](img/code.png)
内存: 一条很长一维数组;
地址 (门牌号) 指针(指向门牌号) 引用(带路党)
## 算法

#### 算法特征:
有穷性、确定性、可行性、输入、输出
#### 算法设计衡量：
正确性、可读性、健壮性, 时间复杂度, 空间复杂度
#### 算法分类
![node](img/suanfa.png)
### 基本算法(必会)
* 冒泡 :
* 快速排序:
* 插入
* 选择



## es5三剑客
* this:谁调用this指向谁 改变this指向 (call apply bind)
* 闭包: 函数嵌套函数,函数外部的不能引用函数内部的函数变量,函数内部的可以引用函数外部的变量(用完记得回收掉,容易引起内存泄漏)
* 原型:为一群对象添加属性和方法的对象 __proto__ 指向根
* 原型链:由原型组成的链式查找
* 继承:复用其他对象的属性和方法,来扩张自己的属性和方法
>*	函数提升的优先级高于变量
>*	已经声明的变量再次声明会被忽略
>*	如果局部变量未被声明引用，者默认声明为全局变量，

## 内存泄漏
#### 内存泄漏
>* javaScript 会自动垃圾收集，但是如果我们的代码写法不当，会让变量一直处于“进入环境”的状态，无法被回收

#### 那些会引起内存泄漏
* 1.意外的全局变量
* 2.被遗忘的计时器或回调
* 3.超出DOM引用
* 4.闭包
#### 内存泄漏检测
> Chrome内存分析工具
###### Timeline视图
![Timeline视图](img/timeline.png)
######  Profile视图
![Profile](img/profiles.png)

#### 垃圾回收机制
* 标记清除（mark and sweep）
> 1.垃圾回收器，在运行的时候会给存储在内存中的所有变量都加上标记。
> 2.去掉环境中的变量以及被环境中的变量引用的变量的标记。
> 3.再被加上标记的会被视为准备删除的变量。
> 4.垃圾回收器完成内存清除工作，销毁那些带标记的值并回收他们所占用的内存空间。
> * 大部分浏览器都是使用这种方式进行垃圾回收，区别在于如何标记及垃圾回收间隔而已，只有低版本IE，不出所料，又是IE。

* 引用计数(reference counting)
> 1.    声明了一个变量并将一个引用类型的值赋值给这个变量，这个引用类型值的引用次数就是1。
> 2.    同一个值又被赋值给另一个变量，这个引用类型值的引用次数加1.
> 3.    当包含这个引用类型值的变量又被赋值成另一个值了，那么这个引用类型值的引用次数减1.
> 4.    当引用次数变成0时，说明没办法访问这个值了。
> 5.    当垃圾收集器下一次运行时，它就会释放引用次数是0的值所占的内存。

#### 什么时候触发垃圾回收

## 事件队列
> JavaScript语言的一大特点就是单线程，也就是说，同一个时间只能做一件事

##### 怎么才能多线程
> webworker(html5), 
> concurrent.Thread.js 

#### 任务可以分成两种:
>* 同步任务(synchronous):在主线程上排队执行的任务 **(执行栈)** ，只有前一个任务执行完毕(入栈出栈)，才能执行后一个任务
>* 异步任务(asynchronous):不进入主线程、而进入"任务队列"(task queue)的任务，只有"任务队列"通知主线程，某个异步任务可以执行了，该任务才会进入主线程执行

#### 任务队列分为:
>* 微任务:process.nextTick, Promises, Object.observe, MutationObserver
>* 任务队列:是一个先进先出的数据结构，排在前面的事件，优先被主线程读取

## [node 相关](https://github.com/Silence520/Documentdescription/tree/master/node%E7%9B%B8%E5%85%B3)
![node](img/node.png)
> [node 相关](https://github.com/Silence520/Documentdescription/tree/master/node%E7%9B%B8%E5%85%B3)

## js设计模式
>* 单例模式
>* 代理模式
>* 命令模式
>* 职责链模式
>* 发布订阅者模式
>* 工厂模式
>* 迭代器模式
>* 适配器模式

## 函数式编程
 >  纯函数
 >  函数组合f(g(y(x))
 >  函数的柯里化
 >  Point Free 

## 安全
#### 混淆
> 混淆:具体处理为重命名局部变量、在相同语义 的情况下压缩代码，比如去掉末尾分号(Remove Terminator Semicolons)，常量替 换(Constant Propagation)、移除代码空白(Space、Tab、Line-Feed)全局变量 不会更名如LocalStorage。
####  常⽤用混淆技术
 UglifyJS, JS Packer, Closure Compiler, JS Min

![node](img/biaoshi.png)
![node](img/luoji.png)
![node](img/aaencode.png)
![node](img/jjencode.png)


####  爆破
https://github.com/svent/jsdetox
 http://jsnice.org/
 ```javascript
 Number.prototype.constructor.constructor = function(a) { console.log('--------');
console.log(a);
return Function.apply(null, arguments);
}
```
#### 加密
> 加密重要的目的是出于对商业利益的保护。由于作品太容易被复制窜 改，容易会失去渠道先机
> 加密的目标:减少加密的成本增加破解的成本，需注意 加密后的文件不易过大、没有人工介入不能破解、限制在其他域名部署、不容易被 调试跟踪。

#### 加密算法
> 不基于key的算法就是消息双⽅方都通过⼀一定的 加密和解密算法来进⾏行行通信，这种算法缺点很 明显如果加密算法被破解了了就泄露露了
> key是⼀一个什什么东⻄西呢?随便便你，可以是⼀一个随机产⽣生 的数字，或者⼀一个单词，只要你⽤用的算法认为你选来 做key的东⻄西合法就⾏行行。所以基于key的加密算法⼜又分 为2类:对称加密和不不对称加密

#### 常用的加密手段
base64、md5、 sha1

### AST 语法分析树
![node](img/ast.png)
> 将代码分析成树状结构, transformer 进行遍历,碰到要替换的进行替换.
#### 常见的攻击
> Web前端的黑客攻防技术是一门非常新颖且有趣的黑 客技术，主要包含Web前端安全的跨站脚本(XSS)、 跨站请求伪造(CSRF)、界面操作劫持、WebShell这 几大类，涉及的知识点涵盖信任与非信任关系、Cookie 安全、Flash安全、DOM渲染、字符集、跨域、原生态 攻击、高级钓鱼、蠕虫思想
#### CSRF跨站请求
##### 存在问题
> 被黑客抓包，捕获请求地址，直接修改参数。
> 加入验证码，判断reffer。 这些参数前端都是可以穆 改的。
##### 解决方案
> 验证Token请求。每次动 强验证码+动态Token请求 态刷新。
> 强验证码+动态Token请求

#### 跨站脚本(XSS)
![node](img/xss.png)
payload
xsser

###### 跨站脚本(XSS)防患
![node](img/xssself.png)

